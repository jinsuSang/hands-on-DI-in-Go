# Go 프로그래밍 개발 환경에서 의존성 주입 실습

## 2장 SOLID 디자인 원칙

- 단일 책임 원칙 Single Responsibility Principle SRP
- 개방/폐쇄 원칙 Open/Closed Principle  OCP
- 리스코프 치환 원칙 Liskov Substitution Principle LSP
- 인터페이스 분리 원칙 Interface Segregation Principle ISP
- 의존성 역전 원칙 Dependency Inversion Principle DIP

### 단일 책임 원칙 SRP

> 클래스는 하나의 기능만 가지며, 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다
>
> - 로버트 마틴

- 코드 복잡도가 줄어들고 코드가 작은 단위로 분리되어 테스트가 용이해진다.
- 코드의 재사용 가능성을 높여준다.
- 테스트를 더 쉽게 작성하고 유지 보수를 가능하게 한다.

#### SRP 와 DI의 관계성

- DI를 코드에 적용할 때 일반적으로 의존성 객체를 함수 매개변수로 받은 뒤에 사용한다
- 코드에 삽입된 의존성이 많은 함수가 있는 경우 해당 메서드가 너무 많은 역할을 수행한다는 것을 의미한다.
- SRP는 DI를 언제 어디서 사용할지 파악하는데 도움이 된다.

#### GO 언어에서의 SRP

- 인터페이스, 구조체, 함수
- 인터페이스, 구조체를 여러 부분으로 나누어 테스트 코드가 증가하지만 유사한 테스트 코드가 생성된다.
- 함수에 적용할 때는 새로운 테스트 코드를 작성하지 않아도 된다.
- SRP는 개체를 변경하는 이유를 식별하는데 도움을 준다.
  - 하나 이상의 책임을 갖고 있는 경우이다

### 개방/폐쇄 원칙 OCP

> 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
>
> - 버틀란트 메이어

- 개방 - 새로운 동작과 기능을 추가해서 코드를 확장하거나 조정하는 것
  - 소프트웨어 디자인이나 구조와 관련되어 있음, 새로운 패키지, 인터페이스나 기존의 인터페이스에 새로운 구현을 추가하는 경우이다.
- 폐쇄 - 기존 코드의 변경을 피해야 하는 것
  - 기본 코드와 사용자 API 변경사항을 최소화하는 것이다.

- OCP는 추가 및 확장에 대한 위험을 줄이는데 도움을 준다
- 기능을 추가하거나 제거할 때 필요한 변경 사항을 최소화하는데 도움이 된다
- 버그가 발생할 수 있는 범위를 새롭게 추가된 코드와 해당 코드를 사용하는 부분으로 좁혀준다

#### OCP 와 DI의 관계성

- DI는 의존 관계에 있는 리소스를 추상화하는 코드 방식이다.
- OCP를 사용하면 좀 더 깔끔하고 견고한 추상화를 구현할 수 있다.

#### GO 언어에서의 OCP

- Go 언어에서는 추상 클래스, 상속 등이 없다
- 컴포지션을 통해 추상 클래스를 구현할 수 있다
- 인터페이스를 사용하면 코드 결합도를 낮춰 유지 관리과 용이해지고 쉽게 확장할 수 있다

### 리스코프 치환 원칙 LSP

> 타입 S의 객체 o1과 타입 T의 인스턴스 o2가 있을 때, 어떤 프로그램에서 타입 T의 객체로 P가 사용된다고 하자. S가 T의 서브타입(subtype)이라면 P에 대입된 o1과 o2로 치환된다고 해도 P의 행위는 바뀌지 않는다.
>
> - 바바라 리스코프

> 서브타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.
>
> - 로버트 마틴

- LSP는 동작에 대한 정의만 할 뿐이며 상세 구현은 하지 않는다.

### LSP와 DI의 관계성

- 코드가 주입된 의존성에 관계없이 일관되게 동작한다

- LSP 위반시 OCP 원칙을 위반한다

- LSP 위반시 상위 계층에서 하위 계층의 서비스를 이용할 때 하위 계층의 세부 구현 내용을 코드로 작성해야 하므로 의존성 주입에 의한 추상화가 깨지게 된다

  
